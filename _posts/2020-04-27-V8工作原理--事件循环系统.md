# V8工作原理--事件循环系统

### 事件循环和消息队列

----------

在Javascript中，只有一个主线程，并且主线程非常的忙，既要处理DOM，又要计算样式，还要处理布局，同时还需要处理JS任务以及各种输入事件。为了让这些不同类型的任务在主线程上有条不紊的进行，就需要一个系统来统筹调度任务，这个系统就是接下来要介绍的事件循环系统。

为了将事件循环系统介绍清楚，接下来我会使用C++来写示例，如果你对C++不熟悉，没有关系，都是一些非常简单例子，会Javascript语法就可以看的懂。


#### 使用单线程处理安排好的任务
先从最简单的开始，比如现在有以下4个任务要处理，分别是：
* 任务1：1 + 2
* 任务2：3 + 4
* 任务3：5 + 6
* 任务4: 打印出任务1、任务2、任务3

```java
void main() {
	int num1 = 1 + 2;
	int num2 = 3 + 4;
	int num3 = 5 + 6;
	print("%d, %d, %d", num1, num2, num3);
}
```
在以上代码中，把所有执行任务都放在了主线程中，在执行过程中，主线程会自上而下执行这些任务，等到任务全部执行完毕，主线程将会自动退出。可以参考下图更加直观的了解其执行过程
![Alt text](https://i.ibb.co/wMFfnmc/WX20200414-195244-2x.png)

#### 处理线程执行过程中的新任务
并不是所有的任务都是被提前安排好的，大部分的情况下，新的任务都是在线程执行过程中产生的，那么这些任务该如何被调用执行呢？比如在打印出上面代码的num1、num2和num3之后，又有一个新的任务需要计算两个变量的值，而且这两个变量的值不是固定的。
对于这种情况，就必须使用事件循环机制了。对于事件循环机制到底是怎么运作的，我们可以先使用for循环来模拟一下。

```java
int getInputNumber() {
	int input_number = 0;
	// 输入一个数值
	cin >> input_number;
	// 输入之后返回这个输入的数值
	return input_number;
}

void main() {
	/*
	* 执行被安排好的任务
	*/
	
	// for(;;)表示可以无限循环下去
	for(;;) {
		int num1 = getInputNumber();
		int num2 = getInputNumber();
		int num3 = num1 + num2;
		print("%d, %d, %d", num1, num2, num3);
	}
}
```
上面的代码的执行过程为：在主线程中先执行被安排好的任务，然后再执行for循环语句里面的任务，引入for循环之后，相较于示例1，有以下两点改进：
* 第一点是增加了一个无限循环的for语句，使得线程可以一直循环执行
* 第二点引入了事件，在接受到用户的输入之前，线程都是处于暂停的状态，一旦接受到用户的输入之后，线程就会被激活，然后执行相应的相加和打印任务。

下图简单的描述了一下整个执行过程
![Alt text](https://i.ibb.co/pr015x1/WX20200414-205815-2x.png)

#### 处理从其他线程发送过来的任务
引入了事件循环机制之后，系统就可以在线程执行期间执行新加入的任务。不过在第二版中，所有的任务都是来自于线程内部，如果另外一个来自线程之外的任务需要在线程内部执行，用第二版的线程模型是无法做到的

我们通过一张图来了解一下其他线程是如何发送消息给渲染主线程的
![Alt text](https://i.ibb.co/12BqsYs/WX20200414-211553-2x.png)

从上图可以知道，在渲染主线程执行的过程中，会收到从IO线程发送过来的资源加载完成事件、鼠标点击事件以及其他事件，当接收到这些事件之后，就必须要着手处理了，比如接收到资源加载完成事件之后，就需要去解析DOM，接受到鼠标点击事件之后就需要执行相应的Javascript代码去响应鼠标点击事件。那么这个时候，系统又该启动什么样的机制去有条不紊地执行这些线程之外的事件呢？

为了解决这个问题，就必须使用消息队列去实现了。那么先来了解一下什么是消息队列，如下图：
![Alt text](https://i.ibb.co/cCJr5Nf/WX20200414-213030-2x.png)
消息队列就是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特性，即每一个新的任务都必须添加到队尾，要执行任务的时候，从队首取出。

有了消息队列，我们就可以继续改造第二版的线程模型了，改造方案如下图：
![Alt text](https://i.ibb.co/Sv3Lwnq/Wechat-IMG2.png)


从上图可以看出，从IO线程发送过来的任务都会先添加到消息队列的尾部，等到主线程上的任务执行完毕之后，再取出队列首部的任务执行，改造可分为以下三步：
* 添加一个消息队列
* IO线程中产生的新任务添加到消息队列的尾部
* 渲染主线程会循环的从消息队列首部取出任务，执行任务。

引入消息队列之后，改造之后的代码如下：
```java
// 维护一个消息队列
class TaskQueue {
	Task takeTask();          // 取出队首的任务
	void pushTask(Task task); // 在队尾增加任务
}

void processTask(Task task);

TaskQueue task_queue;
void main() {
	for(;;) {
		Task task = task_queue.takeTask();
		processTask(task); // 执行任务
	}
}
```

#### 处理其他进程发送过来的任务
通过事件循环可以处理线程内部的任务，通过消息队列可以处理从其他线程发送过来的任务，但是在Chrome中，进程之间也是很频繁的发生着交互，那么如何来处理从其他进程发送过来的任务呢？可以参考下图
![Alt text](https://i.ibb.co/vmVRty4/Wechat-IMG3.png)

可以看出，渲染进程有一个IO线程专门处理来自于其他进程的任务，IO线程接受到消息之后，会将这些消息组装程任务发送给渲染主线程，后续步骤就和如何处理其他线程发送过来的任务一致了。

做个小总结：
* 如果有一些确定好的任务，可以使用一个单线程按照顺序来处理这些任务
* 如果需要处理在线程执行过程中新加进来的任务，就需要引入循环语句和事件系统
* 如果需要处理从其他线程发送过来的任务，就需要引入消息队列
* 如果需要处理从其他进程发送过来的任务，那么首先需要通过IPC机制将任务发送给IO线程处理，然后再由IO线程将任务发送给页面主线程

### webApi：setTimeout是怎么实现的


----------
说到定时器，大家都不会陌生，它的作用就是指定某个函数在多少毫秒之后被执行，他会返回一个数值，表示这个定时器的ID，如果不再需要这个定时器的时候，可以通过这个ID来销毁对应的定时器。
下面这段代码演示了定时器最基础的使用方式：
```javascript
const timer = setTimeout(() => {
	console.log('hello world!');
}, 1000);

if ('定时器满足被清除的条件') {
	clearTimeout(timer);
}
```
那么浏览器是怎么实现定时器的呢，定时器任务是如何被执行的以及它和消息队列里面的任务又有什么关系呢？
想要了解定时器原理，首先来回顾一下上面所说的事件循环系统。所有运行在渲染主线程上的任务都需要先被添加到消息队列里面，然后事件循环系统再按照先进先出的执行顺序去执行消息队列里面的任务，典型的事件有以下几种：
* 当接受到HTML文件，渲染引擎就会将“解析DOM”的事件添加到消息队列里面；
* 当浏览器的窗口发生了改变之后，渲染引擎就会将“重新布局”事件添加到消息队列里面；
* 当触发了Javascript垃圾回收机制之后，渲染引擎就会将“垃圾回收”事件添加到消息队列里面；
* 同样如果遇到了一段Javascript异步代码之后，也是需要将回调函数添加到消息队列里面。

上面我们说到，消息队列的特性就是“先进先出”，是有执行顺序的， 但是定时器任务却不是谁先加入消息队列，谁就会被先执行，而是哪个定时器任务最先到期，哪个定时器任务就会被最先执行。所以，不能将定时器任务加入到消息队列中。

实际上，在 Chrome 中除了正常使用的消息队列之外，还另外维护了一个延迟消息队列，这个队列存放一些需要被延迟执行的任务，比如定时器任务。所以当Javascript创建一个定时器之后，便会将这个定时器任务加入到延迟消息队列中。

有了延迟消息队列的概念，我们再来改造一下上面消息循环的代码，大致如下：
```java
// 维护一个消息队列
class TaskQueue {
	Task takeTask();          // 取出队首的任务
	void pushTask(Task task); // 在队尾增加任务
}

void processTask(Task task);
void ProcessDelayTask();

TaskQueue task_queue;
void main() {
	for(;;) {
		Task task = task_queue.takeTask();
		processTask(task); // 执行任务
		// 执行延迟任务
		ProcessDelayTask();
	}
}
```
上面的代码加入了一个ProcessDelayTask函数，这个函数就是专门用来处理延迟任务的，这里需要重点关注一下ProcessDelayTask函数的执行时机，它每次都是在处理完消息队列的一个任务之后被调用，意思就是在每次循环的过程中，当处理完消息队列的一个任务之后，就会去延迟消息队列里面查找是否有到期的延迟任务，有的话就立刻执行这些到期的任务，没有的话就进入下一个事件循环。

#### 使用setTimeout的时候需要注意的问题
在使用定时器的时候，需要注意以下4个问题，避免在使用的时候掉入坑里。

**1.当前任务执行过久，会影响延迟到期定时器任务的执行**
在使用setTimeout的时候，会有很多因素导致定时器里的回调函数没有在预期的时间点被执行，其中一个原因就是当前任务的执行时间过长，从而导致定时器设置的任务被延迟执行。下面的例子就是这样的一个情况
```javascript
function cb() {
	console.timeEnd('cb');
	console.log('我被执行啦！');
}

setTimeout(cb, 0);
console.time('cb');
for(let i = 0; i < 5000; i++) {
	console.log(i);
}
```
将上面的代码扔到浏览器中执行之后，将会打印以下内容
```javascript
cb: 450.80029296875ms
我被执行啦！
```
控制台打印的内容表示cb函数在450毫秒之后才会被执行，而我们给定时器设置的到期执行时间是0毫秒，很明显cb函数没有在预期的时间节点被执行，而是延迟了450毫秒之后才被执行了。

**2. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒**
除了上面说的延迟执行的问题，还有一个容易被忽视的问题就是在未被激活的页面中，setTimeout 执行最小间隔是1000 毫秒，意思就是如果浏览器的标签不是当前打开的标签，那么setTimeout 执行最小间隔是 1000 毫秒，意思就是为了降低性能损耗。

**3. 使用 setTimeout 设置的回调函数中的 this 不符合直觉**
当setTimeout的回调函数执行的是某个对象的方法，那么这个方法里的this指向的并不是这个对象本身，可以通过一个例子来看一下
```javascript
const name = 'wuwenjie';
const obj = {
	name: 'wwj',
	showName: function() {
		console.log(this.name);
	}
}

setTimeout(obj.showName, 1000);
```
执行上面的代码之后，控制台打印的是空，因为超时调用的代码都是在全局作用域中执行的，因此函数中的this指向的是window（非严格模式下，严格模式下指向的undefined），然而这个时候window下面并没有name这个属性，注意我是用const声明name的，所以name变量不会自动变成window属性，如果name变量时候var声明的话，那么这个时候就会打印出'wuwnejie'了。

想要函数按预期打印出obj里的name属性值，我们可以使用箭头函数来改造一下代码（箭头函数不是本章要讨论的，所以不做过多的解释）
```javascript
const name = 'wuwenjie';
const obj = {
	name: 'wwj',
	showName: function() {
		console.log(this.name);
	}
}

setTimeout(() => {
	obj.showName();
}, 1000);
```

第二种方法是使用bind，将showName绑定在obj上
```javascript
setTimeout(obj.showName.bind(obj), 1000);
```

### 宏任务和微任务，不是所有的任务都是一个待遇
----------
在写这篇文章之前，我翻阅了大量有关宏任务和微任务的资料，但是很多文章对宏任务和微任务之间的关联以及执行机制都没有做更深入的介绍，有的甚至是一句话概括：在Javascript中，异步任务分为宏任务和微任务，先执行宏任务再执行微任务。对于宏任务和微任务的理解，仅仅停留在这个层面肯定是不够的，那么接下来，笔者将尽可能将宏任务和微任务之间的关联和执行机制讲明白。

#### 宏任务
上面说到，主线程为了协调各种异步任务有条不紊的工作，引入了事件循环和消息队列。主线程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列，然后再使用for循环，不断的从这些消息队列里面取出任务并执行。我们把存在与这些消息队列里面的任务称为宏任务。

理解了宏任务的执行机制之后我们来看个例子：
```vbscript-html
<html>
    <body>
        <div id='demo'></div>
    </body>
    <script type="text/javascript">
        function timerCallback2(){
          console.log(2)
        }
        function timerCallback(){
            console.log(1)
            setTimeout(timerCallback2,0)
        }
        setTimeout(timerCallback,0)
    </script>
</html>
```
在上面这段代码中，我们希望的是执行完第一个任务之后马上执行第二个任务，中间不要出现其他的任务，不然就会影响第二个任务的到期执行时间了。

但实际往往会出现很多意想不到的问题，比如第一个和第二个任务的执行间隙，就会被插入系统级别的任务，我们打来Performance工具，来看看这两个定时器的执行情况。

![Alt text](https://i.ibb.co/P6ShgmH/WX20200421-210712-2x.png)

可以看到，在第一个任务执行完成之后，第二个任务并没有马上被执行，而是被中间一段一段的任务给阻塞了，试想一下，如果中间插入的任务执行时间过久的话，那么后面的任务就会收到影响。最常见的一个场景就是，我们给一个DOM添加一个点击事件，如果点击事件的回调是一个宏任务，那么可能就会由于前面还有很多宏任务需要执行而延迟执行该任务，造成的问题就是我们不能实时的监听DOM的变化。

所以说宏任务的时间粒度是非常大，对于一些实时性比较高的任务来说，宏任务就不太符合了。
所以为了解决实时性的问题，V8又引入了微任务的概念。

#### 微任务

V8会在内部创建一个微任务队列，这个队列就是用来存放微任务的。因为在执行当前宏任务的时候，可能会产生多个微任务，就需要用队列来维护这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。

也就是说每个宏任务都会关联一个微任务列表，那么微任务是如何产生的以及微任务是何时被执行的呢？

##### 微任务是如何生成的
在浏览器中，微任务产生的方式有两种：
第一种是使用 MutationObserver 监控某个 DOM 节点，然后再通过Javascript来修改这个节点，或者删除，添加节点，当DOM发生改变的时候，就会生成记录DOM变化的微任务。

第二种是使用Promise，当执行Promise.resolve和Promise.reject的时候也会生成微任务。

有了微任务列表之后，那接下来就要看看微任务队列是何时被执行的。

##### 微任务执行时机
通常情况下，在当前宏任务中的Javascript快执行完成时，也就是在Javascript引擎准备退出当前执行栈并清空执行栈的时候，Javascript引擎会检查全局上下文中的微任务队列，如果有微任务队列存在的话，那么就会从微任务队列里取出任务并执行，直到微任务队列为空才会退出当前宏任务。
如果在执行微任务的过程中，产生了新的微任务，同样会将新的微任务加入到当前微任务队列里，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务的过程中产生的微任务不会推迟到下个宏任务执行，而是在当前的宏任务中继续执行。

为了更好的理解微任务的执行时机，可以参考下面的简易流程图：
![Alt text](https://i.ibb.co/5Gyj6SD/WX20200421-214635-2x.png)

#### 总结

在事件循环系统中，宏任务和微任务的执行机制可以总结为一下几点：
* 执行宏任务（栈中没有就从消息队列里拿）
* 执行过程中如果遇到微任务，就将微任务push到当前宏任务下的微任务队列中
* 在开始下一个宏任务之前，检查当前宏任务的微任务队列是否任务，有的话立即执行所有微任务
* 在执行微任务的过程中如果遇到了新的微任务，新的微任务不会推迟到下个宏任务执行，而是在当前的宏任务中继续执行
* 当前宏任务执行完毕，开始执行下一个宏任务。

